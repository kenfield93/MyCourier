'use strict';

const Busboy = require('busboy');
const fs = require('fs-extra');
const streamifier = require('streamifier');

const ACCEPTABLE_MIME = /^(?:multipart\/.+)$/i;
const UNACCEPTABLE_METHODS = [
  'GET',
  'HEAD'
];

module.exports = function(options) {
  options = options || {};

  return function(req, res, next) {
    if (!hasBody(req) || !hasAcceptableMethod(req) || !hasAcceptableMime(req))
        return next();

    processMultipart(options, req, res, next);
  };
};

/**
 * Processes multipart request
 * Builds a req.body object for fields
 * Builds a req.files object for files
 * @param  {Object}   options expressFileupload and Busboy options
 * @param  {Object}   req     Express request object
 * @param  {Object}   res     Express response object
 * @param  {Function} next    Express next method
 * @return {void}
 */
function processMultipart(options, req, res, next) {

 // console.log("looking at req");
 // console.log(req);
 // console.log("req.prototye");
 // console.log(req.prototype);
  let busboyOptions = {};
  let busboy;
  
  req.files = null;

  // Build busboy config
  for (let k in options) {
    if (Object.prototype.hasOwnProperty.call(options, k)) {
      busboyOptions[k] = options[k];
    }
  }

  // Attach request headers to busboy config
  busboyOptions.headers = req.headers;
  //console.log('req.headers');
  //console.log(req.headers);

  // Init busboy instance
  busboy = new Busboy(busboyOptions);

  // Build multipart req.body fields
  busboy.on('field', function(fieldname, val, fieldnameTruncated, valTruncated, encoding, mime) {
    //console.log("when is dis called :( ")
    //console.log("fieldname: %s, val: %s, encoding: %s, mime: %s", fieldname, val, encoding, mime);
    req.emit()
    req.body = req.body || {};

    let prev = req.body[fieldname];

    if (!prev)
      return req.body[fieldname] = val;

    if (Array.isArray(prev))
      return prev.push(val);

    req.body[fieldname] = [prev, val];
  });


  /*
  req.on('data', function(data){

    // console.log('\n\n\nhello there fieldname is: ' + fieldname +'  the data for ' + filename + ' is: ');
     console.log(data);
     for (const b of data) {
       console.log(String.fromCharCode(b));
     }
  });
  */

  //Build req.files fields
  busboy.on('file', function(fieldname, file, filename, encoding, mime) {
    const buffers = [];
    let safeFileNameRegex = /[^\w-]/g;

    file.on('data', function(data) {
     // console.log('\n\n\nhello there fieldname is: ' + fieldname +'  the data for ' + filename + ' is: ');
     // console.log(data);
     // for (const b of data) {
     //   console.log(String.fromCharCode(b));
     // }
      buffers.push(data);

      if (options.debug)
        return console.log('Uploading %s -> %s', fieldname, filename);
    });

    file.on('end', function() {
      if (!req.files)
        req.files = {};

      const buf = Buffer.concat(buffers);
      // see: https://github.com/richardgirges/express-fileupload/issues/14
      // firefox uploads empty file in case of cache miss when f5ing page.
      // resulting in unexpected behavior. if there is no file data, the file is invalid.
      if(!buf.length)
        return;

      if (options.safeFileNames) {
        if (typeof options.safeFileNames === 'object')
          safeFileNameRegex = options.safeFileNames;

        filename = filename.replace(safeFileNameRegex, '');
      }

      let newFile = {
        name: filename,
        data: buf,
        encoding: encoding,
        mimetype: mime,
        mv: function(path, callback) {
          let fstream = fs.createWriteStream(path);

          streamifier.createReadStream(buf).pipe(fstream);

          fstream.on('error', function(error) {
            if (callback)
              callback(error);
          });

          fstream.on('close', function() {
            if (callback)
              callback(null);
          });
        }
      };

      // Non-array fields
      if (!req.files.hasOwnProperty(fieldname)) {
        req.files[fieldname] = newFile;
      } else {
        // Array fields
        if (req.files[fieldname] instanceof Array)
            req.files[fieldname].push(newFile);
        else
            req.files[fieldname] = [req.files[fieldname], newFile];
      }
    });

  });

  let now = next;
 // req.on('finish', function(x){console.log('req called fin');});
  req.on('end', function(x){console.log('req called end expecting busboy finish to call');});

  //req.on('drain', function(x){console.log('req called drain');});
 // req.on('resume', function(x){console.log('req called resume');});
 // req.on('pause', function(x){console.log('req called pause');});

  busboy.on('finish', function(req, res, next){console.log("kill meh. busboy finish "); now(req,res,next);});

  req.pipe(busboy);
}

// Methods below were copied from, or heavily inspired by the Connect and connect-busboy packages

/**
 * Ensures the request is not using a non-compliant multipart method
 * such as GET or HEAD
 * @param  {Object}  req Express req object
 * @return {Boolean}
 */
function hasAcceptableMethod(req) {
  return (UNACCEPTABLE_METHODS.indexOf(req.method) < 0);
}

/**
 * Ensures that only multipart requests are processed by express-fileupload
 * @param  {Object}  req Express req object
 * @return {Boolean}
 */
function hasAcceptableMime(req) {
  let str = (req.headers['content-type'] || '').split(';')[0];

  return ACCEPTABLE_MIME.test(str);
}

/**
 * Ensures the request contains a content body
 * @param  {Object}  req Express req object
 * @return {Boolean}
 */
function hasBody(req) {
  return ('transfer-encoding' in req.headers) ||
    ('content-length' in req.headers && req.headers['content-length'] !== '0');
}
